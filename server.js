
import express from 'express';
import mysql from 'mysql2/promise';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';

// Load environment variables
dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;

// MIDDLEWARES
app.use(cors());
app.use(express.json());

// DATABASE CONNECTION
// Using a pool for better performance and reconnection handling
const pool = mysql.createPool({
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || 'password',
    database: process.env.DB_NAME || 'production_db',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
});

// UTILS: Snake Case (DB) to Camel Case (Frontend)
const toCamel = (o) => {
    if (!o || typeof o !== 'object') return o;
    if (Array.isArray(o)) return o.map(toCamel);
    const n = {};
    Object.keys(o).forEach(k => {
        const camel = k.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
        n[camel] = o[k];
    });
    return n;
};

// --- API ROUTES (/api/...) ---

// Generic Get All
const handleGetAll = (table, orderField = 'id') => async (req, res) => {
    try {
        const [rows] = await pool.query(`SELECT * FROM ${table} ORDER BY ${orderField} ASC`);
        const data = rows.map(r => {
            const camel = toCamel(r);
            // Parse JSON fields if they exist
            if (r.items) camel.items = typeof r.items === 'string' ? JSON.parse(r.items) : r.items;
            if (r.default_colors) camel.defaultColors = typeof r.default_colors === 'string' ? JSON.parse(r.default_colors) : r.default_colors;
            if (r.active_cutting_items) camel.activeCuttingItems = typeof r.active_cutting_items === 'string' ? JSON.parse(r.active_cutting_items) : r.active_cutting_items;
            if (r.splits) camel.splits = typeof r.splits === 'string' ? JSON.parse(r.splits) : r.splits;
            return camel;
        });
        res.json(data);
    } catch (err) {
        console.error(`Error fetching ${table}:`, err);
        res.status(500).json({ error: err.message });
    }
};

app.get('/api/products', handleGetAll('products', 'code'));
app.get('/api/seamstresses', handleGetAll('seamstresses', 'name'));
app.get('/api/fabrics', handleGetAll('fabrics', 'name'));
app.get('/api/orders', handleGetAll('orders', 'created_at DESC'));

// CREATE ORDER
app.post('/api/orders', async (req, res) => {
    try {
        const o = req.body;
        const sql = `INSERT INTO orders (id, reference_id, reference_code, description, fabric, grid_type, status, notes, items, active_cutting_items, splits, created_at, updated_at) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
        await pool.query(sql, [
            o.id, o.referenceId, o.referenceCode, o.description, o.fabric, o.gridType, o.status, o.notes,
            JSON.stringify(o.items || []), JSON.stringify(o.activeCuttingItems || []), JSON.stringify(o.splits || []),
            new Date(o.createdAt), new Date(o.updatedAt)
        ]);
        res.status(201).json({ success: true });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// UPDATE ORDER
app.put('/api/orders/:id', async (req, res) => {
    try {
        const o = req.body;
        const sql = `UPDATE orders SET reference_id=?, reference_code=?, description=?, fabric=?, grid_type=?, status=?, notes=?, items=?, active_cutting_items=?, splits=?, updated_at=?, finished_at=? WHERE id=?`;
        await pool.query(sql, [
            o.referenceId, o.referenceCode, o.description, o.fabric, o.gridType, o.status, o.notes,
            JSON.stringify(o.items || []), JSON.stringify(o.activeCuttingItems || []), JSON.stringify(o.splits || []),
            new Date(), o.finishedAt ? new Date(o.finishedAt) : null, req.params.id
        ]);
        res.json({ success: true });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// DELETE GENERIC
app.delete('/api/:table/:id', async (req, res) => {
    try {
        const { table, id } = req.params;
        // Basic protection for table names
        const allowedTables = ['orders', 'products', 'seamstresses', 'fabrics'];
        if (!allowedTables.includes(table)) return res.status(403).json({error: 'Invalid table'});
        
        await pool.query(`DELETE FROM ${table} WHERE id = ?`, [id]);
        res.json({ success: true });
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

// --- FRONTEND SERVING ---

// Serve the 'dist' folder generated by Vite
app.use(express.static(path.join(__dirname, 'dist')));

// SPA Fallback: Any route that is not API returns index.html
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'dist', 'index.html'));
});

// START SERVER
app.listen(PORT, () => {
    console.log(`=========================================`);
    console.log(`üöÄ PRODUCTION SERVER RUNNING ON PORT ${PORT}`);
    console.log(`üñ•Ô∏è  Frontend: http://localhost:${PORT}`);
    console.log(`üîå API: http://localhost:${PORT}/api`);
    console.log(`=========================================`);
});
